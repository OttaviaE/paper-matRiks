---
title: "matRiks: An R package for the automatic generation of rule-based matrices"
date: "2022-11-09"
abstract: >
 Few resources are available for the automatic generation of Raven-like matrices. Some of them are no longer working, while others are hardly customizable without strong programming skills. An R package fro the automatic generation of stimuli used for psychological assessment exists, but it is limited to one shape and to the manipulation of one rule (i.e., rotation). The \CRANpkg{matRiks} package has been developed with the aim of overcoming the above mentioned issues. This package can generate matrices considering different types of rules, starting from the most basic ones (e.g., changes in size, objects orientation) to the most complex ones, based on inferential and inductive reasoning. This unveils the possibility of generating new customizable stimuli and of systematically manipulating the difficulty of the matrices. Being developed within the R environment, the \CRANpkg{matRiks} package is completely open-source, allows for the reproducibility of the stimuli, and it can be easily used  by people with basic knowledge of R language.
draft: true
author:  
  - name: Quietest Quokka
    affiliation: University of Little Mates
    address:
    - Department of Letter Q
    - Somewhere, Australia
    url: https://www.britannica.com/animal/quokka
    orcid: 0000-1721-1511-1101
    email:  qquo@ulm.edu
  - name: Bounciest Bilby
    affiliation:
    - University of Little Mates
    - University of Aussie Animals
    address:
    - Department of Letter Q, Somewhere, Australia
    - Department of Marsupials, Somewhere, Australia
    url: https://www.britannica.com/animal/bilby
    email: bbil@ulm.edu
    orcid: 0000-0002-0912-0225
type: package
output: 
  rjtools::rjournal_article:
    self_contained: yes
    toc: no
bibliography: RJreferences.bib
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE, warning = FALSE, message = FALSE)
library(plotly)
library(ggplot2)
library(palmerpenguins)
library(kableExtra)
library(data.table)
library(matRiks)
library(knitr)
library(kableExtra)
```

# Introduction

Cattell (@cattell1963) defined fluid intelligence (*g*) as the ability of solving novel reasoning problems that has little to do with concepts learned in schools or through acculturational processes. The adjective "fluid" explicitly refers to its ability to "flow" into a variety of tasks and cognitive activities (Horn, 1972). 
Given this definition of fluid intelligence, it appears natural that the instruments for used for its evaluation tap on the respondent's ability to solve abstract problems that involve acculturation as little as possible, such as figural analogies, figure classifications, matrices, and number and letter series are often used (Horn, 1968). 

The Raven's progressive matrices (RPM, @raven1938) are among the most famous tools for the assessment of *g*. The RPM consists in a series of non-verbal multiple-choice stimuli where respondents are required to complete a series of drawings composed of different figures by identifying the relevant features that rule the relationships between the figures. These drawings are often referred to as matrices.
To pursue this aim, the respondents must choose the figure that complete the drawing among a list of other figures, the so-called distractors. 
This task should measure the ability of the respondents to identify and take into account the features (also called "rules") that govern the relationship between the figures to compose the drawing. 
The RPM and similar tasks (here denoted as Raven-like matrices or Raven-like tasks) are employed in different fields, from clinical evaluation of intelligence to the selection processes in organizational psychology (citation needed). 
Since Raven's and Raven-like tasks involve the ability to solve new abstract problems, the stimuli composing these tasks should not be spread among the general population. 
However, new stimuli can be generated according to the rules that govern the relationships between the figures composing the drawing. Indeed, different resources are available for developing Raven-like tasks, such as Sandia (cit), Corvus (cit), and the R package \CRANpkg{Imak} (cit). 

The stimuli generated with Sandia have been analysed in an Item Response Theory framework to validate them as a test for measuring fluid intelligence. 
The stimuli are available upon request to the authors, however no new stimuli can be generated because the code on which Sandia is based is no longer maintained. 
Corvus represents another possible resource for generating Raven-like tasks. Corvus is written in Javascript but the Author provided a nice and easy-to-use graphical interface where the user can specify the figures and the rule(s) for the generation of the matrices. However, Corvus provides few degrees of freedom in  terms of both the figures and the number of rules that can be manipulated through the graphical interface. If the user wants to add other figures, to modify the already existing figures, or to implement new rules, they have to modify the source code in Javascript, which might be a quite demanding task for people with little to null experience in programming. 
Finally, the `ImaK` package is an `R` package that allows for generating visual analogies. The code for generating such stimuli (along with their response options) is quite straightforward and easy to use. However, the stimuli that can be generated with the `ImaK` package are mostly based on the rotation of the same figure to which some objects can be added or removed. As such, the only rule that is manipulated is the spatial rotation of the figures.  


Given the limitations of the existing resources for generating Raven-like tasks, there might be the need of an open-source, easy-to-use, and constantly maintained resource for generating such stimuli through the systematic manipulation of rules applied to different figures. 
The `matRiks` package (@matRiks) has been developed to pursue these aims.
Beyond generating the matrix by manipulating one or multiple rules at once on one or multiple figures, the `matRiks` package generates the response list associated to the matrix as well. 
The systematic manipulation of both the rules and the figures for the matrix generation should grant the possibility of grading the granularity of the difficulty of the matrices by manipulating one element at the time. 
In a similar vein, the package should allow for generating matrices that can be considered equivalent in terms of rules employed for their generation but differ in terms of figures composing the drawing. In what follows, the term stimulus is used to identify the matrix with its associated response list.   

The manuscript is organized as follows. 
The next section presents the rules that usually employed in the RPM along with the specific types of error responses (i.e., distractors) that compose the response list associated with a matrix. Then, the `matRiks` package is presented through an example of its application for the generation of different stimuli (i.e., the matrix with its associated response list).


# Background

### Rule based matrices 

Literature highlights a plethora of rules that can be manipulated for the generation of the raven-like tasks (cit cit cit). 
Beyond the fact that some of these rules have different names in different sources but refer to the same manipulation (e.g., the rule defined as "and problem" in Harris el a. 2020 is called "intersection" rule in Arendasy et al. 2005), they can be summarized into different macro-categories, namely visuospatial rules (i.e., the manipulation concerns the graphical and spatial features of the figures, Figure \@ref(fig:visuoRule)), and logical rules (i.e., the manipulation concerns the logical relationships between the figures composing the matrix, , Figure \@ref(fig:logiRule)). The rules can be applied (i.e., manipulated) to different figures or concatenation of figures to generate a matrix.




```{r visuoRule, out.width="70%", fig.align="center", fig.cap="Example of visuospatial rule: Changes in size"}
a = mat_apply(maxi(), hrules = "size")

par(mfrow =c(1, 3) ,
        mar = c(6,5,5,5))

draw(a$Sq1); draw(a$Sq2); draw(a$Sq3)
```

```{r logiRule, out.width="70%", fig.align="center", fig.cap="Example of logical rule: Insiemistic Interscetion AND"}
size.x = 8 
size.y = 4 
pos.x = 0 
shd = NA 
lty = 1 
lwd = 3

par(mfrow =c(1, 3) ,
        mar = c(6,5,5,5))

a = mat_apply(cof(luck(pos.x = pos.x + size.x, pos.y = pos.x, rot = pi, 
        size.x = size.x, size.y = size.y, shd = shd, lty = lty, 
        lwd = lwd), luck(pos.x = pos.x - size.x, pos.y = pos.x, 
        rot = -pi, size.x = size.x, size.y = size.y, shd = shd, 
        lty = lty, lwd = lwd), luck(pos.x = pos.x, pos.y = pos.x + 
        size.x, rot = -pi, size.x = size.y, size.y = size.x, 
        shd = shd, lty = lty, lwd = lwd), luck(pos.x = pos.x, 
        pos.y = pos.x - size.x, rot = -pi, size.x = size.y, size.y = size.x, 
        shd = shd, lty = lty, lwd = lwd)), hrules = "AND")

draw(a$Sq1); draw(a$Sq2); draw(a$Sq3)
```

In Figure \@ref(fig:visuoRule), the manipulation concerns a specif feature of the figure, that is its size, and it can be observed as the the figure decreases its size across the cells. 
The rightmost cell contains the figure with the smallest size, the middle cell contains a figure with medium-small size while the leftmost object contains the figure with its original size. 
In Figure \@ref(fig:logiRule), the manipulation concerns the relationships between the objects composing the figures, which are combined together according to a logical rule based on the insiemistic intersection of the objects. Specifically, the figure in the rightmost cell results from the intersection of the objects in the leftmost cell and in the middle cell.


Both visuospatial and logical rules can be manipulated according to different directional logic. 
Specifically, the rules can be applied horizontally (i.e., the manipulation of the rule can be seen across columns but not across rows, H direction), vertically (i.e., the manipulation of the rule can be seen across rows but not across columns, V direction), or diagonally (i.e., the manipulation of the rule can be seen both across columns and across rows). Concerning the diagonal directional logic, it can follow either the main diagonal of the matrix (i.e., the manipulation of the rule can be seen from the top-left corner to the low-right corner, TL-LR direction) or the secondary diagonal of the matrix (i.e., the manipulation of the rule can be seen from the low-left corner to the top-right corner, LL-TR direction).


### The response options

A large corpus of literature has investigated the role of the distractors in the response processes involved when solving the Raven matrices, focusing on the specific error response chosen by the respondent (@fort, @kunda, @storme). 
The underlying logic is that the incorrect response is not chosen at random by the respondent, but it can be the result of an educated guess, or it can be chosen because the respondent is misled for a definite reason. 
In other words, the incorrect responses might reflect an incorrect solution strategy which results in the choice of a specific distractor type over another one [@kunda]. The distractors can be classified according to the incorrect response strategy they represent. 
@kunda present a list of criteria for the identification of the distractors in the SPM based on the error types from the CPM and APM manuals [@raven2004]. Specifically, the specific response that is chosen in place of the correct one (i.e. error types) can be collected into four main four conceptual errors, namely Repetition (R), Difference (D), Wrong Principle (WP), and Incomplete Correlate (IC). 
Repetition errors occur when the chosen response option is a cell adjacent to the blank space. 
Difference errors occur when the chosen response option is completely different from any entry of the matrix. 
Wrong principle errors occur when the chosen response option follows rules other than the ones used in the matrix. Incomplete Correlate errors occur when the chosen response option is in fact the correct response with a variation on a single feature. Each of the four main error types can be further described by their subcategories.  
The definitions of each error type and of their specific subcategories are summarized in Table \@ref(tab:tab-error-types).

# Customizing tooltip design with \pkg{ToOoOlTiPs}

\pkg{ToOoOlTiPs} is a packages for customizing tooltips in interactive graphics, it features these possibilities.

# A gallery of tooltips examples

The \CRANpkg{palmerpenguins} data [@palmerpenguins]  features three penguin species which has a lovely illustration by Alison Horst in Figure \@ref(fig:penguins-alison). 

```{r penguins-alison, out.width = "100%", out.height = "30%", fig.cap = "Artwork by \\@allison\\_horst", fig.alt="A picture of three different penguins with their species: Chinstrap, Gentoo, and Adelie. "}
knitr::include_graphics("figures/penguins.png")
```

Table `r knitr::asis_output(ifelse(knitr::is_html_output(), '\\@ref(tab:penguins-tab-interactive)', '\\@ref(tab:penguins-tab-static)'))` prints at the first few rows of the `penguins` data:

```{r penguins-tab-interactive, eval = knitr::is_html_output(), layout = "l-body-outset"}
knitr::kable(head(penguins), format = "html", caption = "A basic table")
```

```{r penguins-tab-static, eval = knitr::is_latex_output()}
knitr::kable(head(penguins), format = "latex", caption = "A basic table") %>% 
  kableExtra::kable_styling(font_size = 7)
```   

Figure `r knitr::asis_output(ifelse(knitr::is_html_output(), '\\@ref(fig:penguins-plotly)', '\\@ref(fig:penguins-ggplot)'))` shows an `r ifelse(knitr::is_html_output(), 'interactive', '')` plot of the penguins data, made using the `r knitr::asis_output(ifelse(knitr::is_html_output(), '\\CRANpkg{plotly}', '\\CRANpkg{ggplot2}'))` package. 

```{r penguins-plotly, echo = TRUE, fig.height = 5, fig.cap="A basic interactive plot made with the plotly package on palmer penguin data. Three species of penguins are plotted with bill depth on the x-axis and bill length on the y-axis. When hovering on a point, a tooltip will show the exact value of the bill depth and length for that point, along with the species name.", include=knitr::is_html_output(), eval=knitr::is_html_output(), fig.alt = "A scatterplot of bill length against bill depth, both measured in millimetre. The three species are shown in different colours and loosely forms three clusters. Adelie has small bill length and large bill depth, Gentoo has small bill depth but large bill length, and Chinstrap has relatively large bill depth and bill length."}
p <- penguins %>% 
  ggplot(aes(x = bill_depth_mm, y = bill_length_mm, 
             color = species)) + 
  geom_point()
ggplotly(p)
```

```{r penguins-ggplot, echo = TRUE, fig.height = 5, fig.cap="A basic non-interactive plot made with the ggplot2 package on palmer penguin data. Three species of penguins are plotted with bill depth on the x-axis and bill length on the y-axis. Visit the online article to access the interactive version made with the plotly package.", include=knitr::is_latex_output(), eval=knitr::is_latex_output()}
penguins %>% 
  ggplot(aes(x = bill_depth_mm, y = bill_length_mm, 
             color = species)) + 
  geom_point()
```

# Summary

We have displayed various tooltips that are available in the package \pkg{ToOoOlTiPs}. 
